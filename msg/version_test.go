package msg

import (
	"bytes"
	"net"
	"reflect"
	"testing"
	"time"

	"github.com/elmarsan/havel/protocol"
)

func TestVersion(t *testing.T) {
	data := []byte{
		// Header
		// Magic
		0xf9, 0xbe, 0xb4, 0xd9,
		// Command
		0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00,
		0x00, 0x00, 0x00, 0x00,
		// Length
		0x64, 0x00, 0x00, 0x00,
		// Checksum
		0x35, 0x8d, 0x49, 0x32,

		// body
		// Version
		0x62, 0xea, 0x00, 0x00,
		// Services
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// Unix
		0x11, 0xb2, 0xd0, 0x50, 0x00, 0x00, 0x00, 0x00,

		// AddrRecv services
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		// AddrRecv Ip
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0xff, 0xff, 0x5d, 0xb0, 0x82,
		0x8b,
		// AddrRecv Port
		0x93, 0x59,

		// AddrFrom services
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		// AddrFrom Ip
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0xff, 0xff, 0x5d, 0xb0, 0x82,
		0x8b,
		// AddrFrom Port
		0x93, 0x59,

		// Nonce
		0x3b, 0x2e, 0xb3, 0x5d, 0x8c, 0xe6, 0x17, 0x65,

		// User agent
		0x0F, 0x2F, 0x53, 0x61, 0x74, 0x6F, 0x73, 0x68,
		0x69, 0x3A, 0x30, 0x2E, 0x37, 0x2E, 0x32, 0x2F,

		// Start height
		0xC0, 0x3E, 0x03, 0x00,
	}

	mainnet := protocol.MainNet

	sample := &Version{
		Header: &Header{
			Magic: &mainnet,
			Cmd: &protocol.BitcoinCmd{
				HexData: protocol.VersionCmdData,
				Name:    protocol.VersionCmd,
			},
			Length:   0x64,
			Checksum: 0x32498d35,
		},
		Version:   0xea62,
		Services:  0x00000001,
		Timestamp: time.Unix(1355854353, 0),
		Nonce:     0x6517e68c5db32e3b,
		RecvAddr: &NetAddr{
			Services: 0x00000000,
			Ip: net.IP{
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0xff, 0xff, 0x5d, 0xb0, 0x82, 0x8b,
			},
			Port: 0x9359,
		},
		FromAddr: &NetAddr{
			Services: 0x00000000,
			Ip: net.IP{
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0xff, 0xff, 0x5d, 0xb0, 0x82, 0x8b,
			},
			Port: 0x9359,
		},
		UserAgent: &VarStr{
			VarInt: VarInt{
				Length: 15,
			},
			Val: "/Satoshi:0.7.2/",
		},
		StartHeight: 212672,
	}

	t.Run("Decode", func(t *testing.T) {
		b := bytes.NewBuffer(data)

		version := &Version{}
		err := version.Decode(b)
		if err != nil {
			t.Errorf("Unable to decode (%s)", err.Error())
		}

		if !reflect.DeepEqual(version, sample) {
			t.Error("Wrong decoding")
		}
	})

	t.Run("Encode", func(t *testing.T) {
		b := bytes.NewBuffer([]byte{})

		err := sample.Encode(b)
		if err != nil {
			t.Errorf("Unable to encode (%s)", err.Error())
		}

		if bytes.Compare(b.Bytes(), data) != 0 {
			t.Error("Wrong encoding")
		}
	})
}
